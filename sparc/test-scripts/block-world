

sorts
	#block = [b][0..7].
	#step = 0 .. 2.
	#loc = #block + {t}.
	#fluent = on(#block, #loc).
	#action = put(#block, #loc).

predicates
	on(#block,#loc).
	put(#block,#loc).
	holds(#fluent,#step).
	occurs(#action,#step).
	    
rules
	holds(on(b1,t),0). 
	holds(on(b2,b1),0).
	holds(on(b3,t),0). 
	holds(on(b4,t),0). 
	holds(on(b5,t),0).  
	holds(on(b6,t),0). 

	occurs(put(b4,b2),0).

	% Setting the ability to move blocks
	holds(on(B,L),I+1):- occurs(put(B,L),I).


	% To prevent the block from appearing at two places in same step
	% block B is NOT at location L2 at step I,
	%	if block B is at location L1 at step I,
	%	location L1 and location L2 are NOT equal

	-holds(on(B,L2),I) :-
		holds(on(B,L1),I),
		L1 != L2. 
			




	% Inertia Axiom
	% block B is at location L at step I + 1, 
	%	if block B is at location L at step I, 
	%	if we do not have a reason to believe that block B is NOT at location L at step I + 1

	holds(on(B,L), I+1):-	
		holds(on(B,L), I),
		not -holds(on(B,L), I + 1).

	% Must deal with moved blocks to work with inertia axiom
	% block B is NOT at location L at step I + 1,
	%	if block B is NOT at location L at step I,
	%	if we have no reason to believe that block B is at location L at I + 1

	-holds(on(B,L), I + 1):-
		-holds(on(B,L), I),
		not holds(on(B,L), I + 1).





	
