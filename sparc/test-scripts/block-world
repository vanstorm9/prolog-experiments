sorts
	#block = {a, b, c, d, e, f, t}.
	#step = 0 .. 999.
	#loc = #block + {t}.
	#fluent = on(#block, #loc).
	#action = put(#block, #loc).

predicates
	on(#block,#block).
	put(#block, #loc).
	holds(#fluent, #step).
	occurs(#action, #step).
	    
rules
	holds(on(a,t),0).
	holds(on(b,a),0).
	holds(on(c,t),0).
	holds(on(d,t),0).
	holds(on(e,t),0).
	holds(on(e,f),0).

	occurs(put(d,b),0).


	% Inertia Axiom
	% block B is at location L at step I + 1, 
	%	if block B is at location L at step I, 
	%	if we do not have a reason to believe that block B is NOT at location L at step I + 1

	holds(on(B,L), I+1):-	
		holds(on(B,L), I),
		not -holds(on(B,L), I + 1).

	% Must deal with moved blocks to work with inertia axiom
	% block B is NOT at location L at step I + 1,
	%	if block B is NOT at location L at step I,
	%	if we have no reason to believe that block B is NOT at location L at I + 1

	-holds(on(B,L), I + 1):-
		holds(on(B,L), I),
		not -holds(on(B,L), I + 1).
